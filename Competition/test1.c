#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  ,               sensorTouch)
#pragma config(Sensor, dgtl2,  ,               sensorSONAR_cm)
#pragma config(Sensor, dgtl4,  ,               sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,            ,             tmotorVex269_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,            ,             tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port5,            ,             tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include <GLOBAL2.h>

#define trc 35.0
#define dia 10.16
#define fix 1

bool arcade = false;		// Whether to be in arcade mode or not
bool clawopen = true;	  // Whether or not the claw is open
bool oldcl = false;			// was the claw opened last cycle?
bool oldbtn = false; 		// the last value of vexRT[Btn8D] to help with switching arcade mode
bool oldbtn2 = false;		// the last value of vexRT[Btn7R] to help with opening and closing the
int offset = 0;


void ArcadeFlip(bool btn, bool old){		// function to switch arcade mode
	if(btn && !old && arcade){ 						// if the button is on and it wasn't on before and arcade is on then
		arcade = false;											// turn arcade off.
	} else if(btn && !old && !arcade){		// if the button is on and it wasn't on before and arcade is off then
		arcade = true;											// turn arcade on.
	}
}


void PIDMotorSync(int armpos,int clawpos){
	clawpos *= 2.5;
	float foo = (offset-clawpos-armpos);
	motor[port6] = foo;//*(!(foo > 127 || foo < -127))+(127*(foo > 127))+(-127*(foo < -127));
}


task killswitch(){ 						// The task to listen for the killswitch to be pressed and stop the program if it is.
	while(1){ 									// do this forever, unless it's stopped by itself
		if(SensorValue[dgtl1]){		// If the killswitch (port 1) is pressed, then
			stopAllTasks();					// stop all tasks (this one and task main).
		}
	}
}

task claw(){												// the task to open and close the claw
	if(clawopen){											// if the claw should be open
		motor[port7] = -127;						// Open the claw
		wait1Msec(500);									// wait for it to open fully
		motor[port7] = 0;								// turn off the motor
	} else if(!clawopen){							// but if the claw isn't supposed to be open (so it should close)
		motor[port7] = 127;							// close the claw fast
		wait1Msec(500);									// wait for it to close
		motor[port7] = 50;							// then apply a constant indefinitely to hold the thing
	}
}

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	nMotorEncoder[port2] = 0;
	nMotorEncoder[port3] = 0;
	nMotorEncoder[port5] = 0;
	MoveDist(-10,100,dia);
	MoveDist(10,100,dia);
	motor[port4] = -100;
	motor[port5] = 100;
	motor[port6] = 70;
	motor[port7] = -50;
	while(nMotorEncoder[port5] < 300){}
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port2] = 50;
	motor[port3] = -50;
	wait1Msec(300);
	motor[port7] = 0;
	while(SensorValue[dgtl4] > 30 || SensorValue[dgtl2] == -1){}
	motor[port2] = -60;
	motor[port3] = 60;
	wait1Msec(100);
	motor[port2] = 30;
	motor[port3] = 30;
	while(SensorValue[dgtl4] > 4 || SensorValue[dgtl2] == -1){}
	motor[port2] = 0;
	motor[port3] = 0;
	motor[port7] = 100;
	wait1Msec(500);

	motor[port7] = 5;
	motor[port4] = -100;
	motor[port5] = 100;
	motor[port6] = -100;
	motor[port2] = -60;
	motor[port3] = -60;

	while(nMotorEncoder[port5] < 500){}
	wait1Msec(200);

	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port2] = -50;
	motor[port3] = 50;
	wait1Msec(500);
	while(SensorValue[dgtl2] > 40 && SensorValue[dgtl2] != -1){}
	wait1Msec(50);

	motor[port2] = 40;
	motor[port3] = 40;

	while(SensorValue[dgtl2] > 20 && SensorValue[dgtl2] != -1){}

	motor[port2] = 0;
	motor[port3] = 0;
	motor[port7] = 5;
	motor[port4] = 100;
	motor[port5] = -100;
	motor[port6] = 110;

	while(nMotorEncoder[port5] > 100){}

	motor[port7] = -100;
	MoveDist(-5,100,dia);

	motor[port2] = 0;
	motor[port3] = 0;
	motor[port7] = 0;
	motor[port4] = 0;
	motor[port5] = 0;
	motor[port6] = 0;
	motor[port7] = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol(){
	startTask(killswitch); // Start the task to listen for killswitch press

	nMotorEncoder[port5] = 0;
	nMotorEncoder[port6] = 0;

	while(1){ // Do this forever, unless the task is stopped.

		bool c1 = (vexRT[Ch1] > 10)||(vexRT[Ch1] < -10);
		bool c2 = (vexRT[Ch2] > 10)||(vexRT[Ch2] < -10);
		bool c3 = (vexRT[Ch3] > 10)||(vexRT[Ch3] < -10);

		if(arcade){ 	//................................ the code that runs the joysticks is dependant on arcade mode.
			motor[port2] = (vexRT[Ch2]*c2+vexRT[Ch1]*c1)*0.9; 		// left wheel
			motor[port3] = (vexRT[Ch2]*c2-vexRT[Ch1]*c1)*0.9; 		// right wheel
			motor[port4] = -(vexRT[Ch3]*c3)-20; 							// left arms
			motor[port5] = (vexRT[Ch3]*c3)+20; 								// right arms
		} else { 			//................................ if it's not in arcade mode...
			motor[port2] = vexRT[Ch3]*0.9*c3;									// left wheel to left joystick
			motor[port3] = vexRT[Ch2]*0.9*c2;									// right wheel to right joystick
			motor[port4] = -(vexRT[Btn6U]-vexRT[Btn6D])*127-20;			// left arms to a button
			motor[port5] = (vexRT[Btn6U]-vexRT[Btn6D])*127+20;			// right arms to a button
		} 						//........................................ the buttons below don't change.
		motor[port6] = -(-vexRT[Btn5U]*127+vexRT[Btn5D]*127);


		if(vexRT[Btn7R] && !oldcl && clawopen){						// if 7l is pressed and the claw mode wasn't switched last cycle
			clawopen = false;																// make it false and close the claw
			oldcl = true;																		// set the oldcl variable to true;
			startTask(claw);                              	// do the claw
		} else if(vexRT[Btn7R] && !oldcl && !clawopen){		// if 7r is pressed and the claw wasn't switched
			clawopen = true;																// make it open
			oldcl = true;																		// set oldcl to true
			startTask(claw);	// do the claw
		}
		if(!vexRT[Btn7R] && oldcl){												// if no longer holding btn7r and oldcl is true
			oldcl = false;																	// make oldcl false
		}





		ArcadeFlip(vexRT[Btn8D], oldbtn);	// Function to switch to and from arcade mode
		oldbtn2 = vexRT[Btn7R];						// Set oldbtn2 to the value of vexRT[btn8d] for the next cycle
		oldbtn = vexRT[Btn8D]; 						// Set the value of oldbtn to the current vexRT[Btn8D] so it can be compared to the one
	}																		// on the next cycle.
}
